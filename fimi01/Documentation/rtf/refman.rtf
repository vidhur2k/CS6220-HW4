{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment APRIORI algorithm Reference Manual}APRIORI algorithm}
{\comment Generated byDoxgyen. }
{\creatim \yr2003\mo12\dy23\hr23\min59\sec0}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
An efficient implemenation of APRIORI algorithm \par \pard\plain 
{\tc \v An efficient implemenation of APRIORI algorithm}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This program is a very efficient implementation of APRIORI algorithm proposed by Rakesh Agrawal and Ramakrishnan Srikant. APRIORI is the most basic and well-known algorithm to find frequent itemsets in a transactional database.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Frequent Itemset Mining problem\par
}
\par
A {\i transactional database}  consists of sequence of transaction: $T=\langle t_1,\ldots ,t_n\rangle $. A transaction is a set of items ($t_i\in I$). Transactions are often called {\i baskets} , referring to the primary application domain (i.e. market-basket analysis). A set of items is often called {\i itemset}  by the data mining community. The {\i (absolute) support}  or the {\i occurrence}  of $X$ (denoted by $supp(X)$) is the number of transactions that are supersets of $X$ (i.e. that {\i contain}  $X$). The {\i realtive support}  is the absolute support divided by the number of transactions (i.e. {\i n} ). An itemset is {\i frequent}  if its support is greater or equal than a threshold value.\par
In the frequent itemset mining problem a transaction database and a relative support threshold (traditionally denoted by {\i min_supp} ) is given and we have to find all frequent itemsets. \par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl \v 4}Association Rule Mining problem\par
}
\par
This program is also capable of mining association rules. An association rule is like an implication: $X\to Y $ means that if itemset {\i X}  occurs in a transaction, than itemset {\i Y}  also occurs with high probability. This probability is given by the {\i confidence}  of the rule. It is like an approxiamtion of {\i p(Y|X)} , it is the number of transactions that contain both {\i X}  and {\i Y}  divided by the number of transaction that contain {\i X} , thus $conf(X\to Y)=\frac{supp(X\cup Y)}{supp(X)}$. The {\i relative support}  of the association rule $X\to Y $ is the support of itemset $X \cup Y $. The lift of $X\to Y $ tries to capture the independence of the antecedent and the consequent of the rule: $lift(X\to Y)=\frac{supp(X\cup Y)}{supp(X)supp(Y)}$ An association rule is {\i valid}  if its confidence, support and lift are greater than or equal than corresponding threshold values.\par
In the association rule mining problem a transaction database and a relative support threshold (traditionally denoted by {\i min_supp} ), a confidence threshold (traditionally denoted by {\i min_conf} ), and a lift threshold is given and we have to find all valid association rules.  \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
APRIORI algorithm Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
{\b {\b std} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
APRIORI algorithm Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
Apriori\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
itemsetLess\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Trie\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Trie_hash\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
APRIORI algorithm Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
{\b {\b Apriori} (This class implements the APRIORI algirithm )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b itemsetLess} (This struct is responsible for comparing two itemsets )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Trie} (Trie (or prefix-tree) is a tree-based datastructure )} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Trie_hash} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
APRIORI algorithm File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
\par
{\b {\b Apriori.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Apriori.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Trie.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Trie.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Trie_hash.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Trie_hash.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std Namespace Reference\par \pard\plain 
{\tc\tcl2 \v std}
{\xe \v std}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Apriori Class Reference\par \pard\plain 
{\tc\tcl2 \v Apriori}
{\xe \v Apriori}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This class implements the APRIORI algirithm.  
\par
{\f2 #include <Apriori.hpp>}\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Apriori} (const  bool &{\b store_input}, const  int &trie_type=1, const  int &child_threshold=5)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b APRIORI_alg} (ofstream &outcomefile, const  char *basket_filename, const  double &min_supp, const  double &min_conf)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i This procedure implements the APRIORI algorithm. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_in_a_line} (FILE *filepoint)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Reads in one transaction from the datafile. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b support} (FILE *filepoint, const  {\b itemtype} &candidate_size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Determines the support of the candidates of the given size. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Trie} * {\b trie}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b itemtype} > {\b basket}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b basket_number}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< vector< {\b itemtype} >, unsigned long, {\b itemsetLess} > {\b reduced_baskets}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b store_input}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This class implements the APRIORI algirithm. \par
\par
APRIORI is a levelwise algorithm. It scans the transaction database several times. After the first scan the frequent 1-itemsets are found, and in general after the {\i k{\super th} }  scan the frequent {\i k} -itemsets are extracted. The method does not determine the support of every possible itemset. In an attempt to narrow the domain to be searched, before every pass it generates {\i candidate}  itemsets. An itemset becomes a candidate if every subset of it is frequent. Obviously every frequent itemset needs to be candidate too, hence only the support of candidates is calculated. Frequent {\i k} -itemsets generate the candidate {\i k+1} -itemsets after the $k^{th}$ scan. \par
After all the candidate {\i k+1} -itemsets have been generated, a new scan of the transactions is effected and the precise support of the candidates is determined. The candidates with low support are thrown away. The algorithm ends when no candidates can be generated. \par
The intuition behind candidate generation is based on the following simple fact:\par
 {\i Every subset of a frequent itemset is frequent.} \par
 This is immediate, because if a transaction {\i t}  supports an itemset {\i X} , then {\i t}  supports every subset $Y\subseteq X$. \par
Using the fact indirectly, we infer, that if an itemset has a subset that is infrequent, then it cannot be frequent. So in the algorithm APRIORI only those itemsets will be candidates whose every subset is frequent. The frequent {\i k} -itemsets are available when we attempt to generate candidate {\i k+1} -itemsets. The algorithm seeks candidate {\i k+1} -itemsets among the sets which are unions of two frequent {\i k} -itemsets. After forming the union we need to verify that all of its subsets are frequent, otherwise it should not be a candidate. To this end, it is clearly enough to check if all the {\i k} -subsets of {\i X}  are frequent. \par
Next the supports of the candidates are calculated. This is done by reading transactions one by one. For each transaction {\i t}  the algorithm decides which candidates are supported by {\i t} . To solve this task efficiently APRIORI uses a hash-tree. However in this implementation a trie (prefix-tree) is applied. Tries have many advantages over hash-trees. {
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab It is faster  \par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab It needs no parameters (main drawback of a hash-tree is that its performance is very sensitive to the parameteres)  \par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab The candidate generation is very simple.  \par
}
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Apriori\:Apriori}
{\xe \v Apriori\:Apriori}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Apriori::Apriori (const bool & {\i store_input}, const int & {\i trie_type} = 1, const int & {\i child_threshold} = 5)}
}\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v APRIORI_alg\:Apriori}
{\xe \v Apriori\:APRIORI_alg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apriori::APRIORI_alg (ofstream & {\i outcomefile}, const char * {\i basket_filename}, const double & {\i min_supp}, const double & {\i min_conf})}
}\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This procedure implements the APRIORI algorithm. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i outcomefile} The file the output will be written to. \par
{\i basket_filename} The name of the datafile that contains the transactions. \par
{\i min_supp} The relative support threshold \par
{\i min_conf} The confidence threshold for association rules. If min_conf=0 no association rules will be extraced. \par
}
\par
\par
}
{\xe \v read_in_a_line\:Apriori}
{\xe \v Apriori\:read_in_a_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apriori::read_in_a_line (FILE * {\i filepoint}){\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads in one transaction from the datafile. \par
\par
\par
}
{\xe \v support\:Apriori}
{\xe \v Apriori\:support}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Apriori::support (FILE * {\i filepoint}, const {\b itemtype} & {\i candidate_size}){\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determines the support of the candidates of the given size. \par
\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v basket\:Apriori}
{\xe \v Apriori\:basket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b itemtype}> {\b Apriori::basket}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v basket_number\:Apriori}
{\xe \v Apriori\:basket_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long {\b Apriori::basket_number}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v reduced_baskets\:Apriori}
{\xe \v Apriori\:reduced_baskets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map<vector<{\b itemtype}>, unsigned long, {\b itemsetLess}> {\b Apriori::reduced_baskets}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v store_input\:Apriori}
{\xe \v Apriori\:store_input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b Apriori::store_input}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v trie\:Apriori}
{\xe \v Apriori\:trie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Trie}* {\b Apriori::trie}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Apriori.hpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Apriori.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
itemsetLess Struct Reference\par \pard\plain 
{\tc\tcl2 \v itemsetLess}
{\xe \v itemsetLess}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This struct is responsible for comparing two itemsets.  
\par
{\f2 #include <Apriori.hpp>}\par
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (const  vector< {\b itemtype} > &basket_1, const  vector< {\b itemtype} > &basket_2) const \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This struct is responsible for comparing two itemsets. \par
\par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Bodon Ferenc \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:itemsetLess}
{\xe \v itemsetLess\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool itemsetLess::operator() (const vector< {\b itemtype} > & {\i basket_1}, const vector< {\b itemtype} > & {\i basket_2}) const{\f2  [inline]}}
}\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Apriori.hpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Trie Class Reference\par \pard\plain 
{\tc\tcl2 \v Trie}
{\xe \v Trie}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Trie (or prefix-tree) is a tree-based datastructure.  
\par
{\f2 #include <Trie.hpp>}\par
Inheritance diagram for Trie:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classTrie.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Trie} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b candidate_generation} (const  {\b itemtype} &frequent_size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Generates candidates. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b find_candidate} (const  vector< {\b itemtype} > &basket, const  {\b itemtype} candidate_size, const  unsigned long counter=1)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Increases the counter of those candidates that are contained by the given basket. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delete_infrequent} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes unfrequent itemsets. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b association} (ofstream &outcomefile, const  double min_conf) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Generates association rules. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b basket_recode} (vector< {\b itemtype} > &basket) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Recodes the basket so that each item is substituted by its s frequency order (inv_orderarray[]). }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b node_number} () const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returns the number of nodes in the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b statistics} () const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Displays the memory need of the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_content_to_file} (ofstream &outcomefile) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Writes the content (frequent itemsets) to the file. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b show_content} () const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Displays the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Trie} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b max_path_set} (const  unsigned long state_index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Sets the maximal path value. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b delete_edge} (const  unsigned long from_state, const  unsigned long to_state)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the edge that goes to a given state. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b add_empty_state} (const  unsigned long from_state, const  {\b itemtype} item, const  unsigned long counter=0)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Adds an empty state to the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned long {\b is_included} (const  set< {\b itemtype} > &an_itemset) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i It decides whether the given itemset is included in the trie or not. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_all_subset_frequent} (const  set< {\b itemtype} > &maybe_candidate) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Decides if all subset of of an itemset is contained in the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b candidate_generation_two} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Generates candidate of size two. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b candidate_generation_assist} (unsigned long actual_state, const  {\b itemtype} frequent_size, const  {\b itemtype} actual_sizet, set< {\b itemtype} > &maybe_candidate)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Generates candidate of size more than two. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b find_candidate_one} (const  vector< {\b itemtype} > &basket)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Increases the counter for those items that are in the given basket. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b find_candidate_two} (const  vector< {\b itemtype} > &basket, const  unsigned long counter=1)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Increases the counter for those itempairs that are in the given basket. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b find_candidate_more} (const  vector< {\b itemtype} > &basket, const  {\b itemtype} candidate_size, vector< {\b itemtype} >::const_iterator it_basket, const  unsigned long actual_state, const  {\b itemtype} actual_size, const  unsigned long counter=1)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Increases the counter for those itemsets that is contained by the given basket. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b delete_infrequent_one} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the nodes that represent infrequent itemsets of size 1. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b delete_infrequent_two} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the nodes that represent infrequent itemsets of size 2. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b delete_infrequent_more} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the nodes that represent infrequent itemsets. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b assoc_rule_find} (ofstream &outcomefile, const  double min_conf, set< {\b itemtype} > &condition_part, set< {\b itemtype} > &consequence_part, const  unsigned long union_support) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b assoc_rule_assist} (ofstream &outcomefile, const  double min_conf, unsigned long actual_state, set< {\b itemtype} > &consequence_part) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b write_content_to_file_assist} (ofstream &outcomefile, const  unsigned long actual_state, const  {\b itemtype} item_size, const  {\b itemtype} actual_size, set< {\b itemtype} > &frequent_itemset) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Writes out the content of the trie (frequent itemset and counters). }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< vector< {\b itemtype} > > {\b itemarray}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i itemarray stores the label of the edges. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< vector< unsigned long > > {\b statearray}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i stetearray stores the end node of the edges. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< unsigned long > {\b countervector}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i countervector stores the occurences of the itemsets }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< unsigned long > {\b parent}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< vector< unsigned long > > {\b temp_counter_array}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i temp_counter_array stores the occurences of the itempairs }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b itemtype} > {\b maxpath}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i maxpath stores the legth of the longest paths. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b itemtype} > {\b orderarray}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The frequency order of the items. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b itemtype} > {\b inv_orderarray}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i inverse of orderarray: orderarray[inv_orderarray[i]]=i }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Trie (or prefix-tree) is a tree-based datastructure. \par
\par
Trie is a rooted directed tree. The root is defined to be at depth 0, and a node at depth {\i d}  can point to nodes at depth {\i d+1} . A pointer is also called edge or link, which is labeled by an item. If node {\i u}  points to node {\i v} , then we call {\i u}  the parent of {\i v} , and {\i v}  is a child node of {\i u} . \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Trie\:Trie}
{\xe \v Trie\:Trie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Trie::Trie ()}
}\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v ~Trie\:Trie}
{\xe \v Trie\:~Trie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Trie::~{\b Trie} (){\f2  [virtual]}}
}\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add_empty_state\:Trie}
{\xe \v Trie\:add_empty_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::add_empty_state (const unsigned long {\i fromState}, const {\b itemtype} {\i item}, const unsigned long {\i counter} = 0){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Adds an empty state to the trie. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i fromState} The state number that point to the new state. \par
{\i item} The label of the new edge \par
{\i counter} The initial counter of the new state \par
}
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v assoc_rule_assist\:Trie}
{\xe \v Trie\:assoc_rule_assist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::assoc_rule_assist (ofstream & {\i outcomefile}, const double {\i min_conf}, unsigned long {\i actual_state}, set< {\b itemtype} > & {\i consequence_part}) const{\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v assoc_rule_find\:Trie}
{\xe \v Trie\:assoc_rule_find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::assoc_rule_find (ofstream & {\i outcomefile}, const double {\i min_conf}, set< {\b itemtype} > & {\i condition_part}, set< {\b itemtype} > & {\i consequence_part}, const unsigned long {\i union_support}) const{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v association\:Trie}
{\xe \v Trie\:association}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::association (ofstream & {\i outcomefile}, const double {\i min_conf}) const}
}\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Generates association rules. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i outcomefile} The file the output will be written to. \par
{\i min_conf} Confidence threshold. \par
}
\par
\par
}
{\xe \v basket_recode\:Trie}
{\xe \v Trie\:basket_recode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::basket_recode (vector< {\b itemtype} > & {\i basket}) const}
}\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Recodes the basket so that each item is substituted by its s frequency order (inv_orderarray[]). \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i basket} The given basket. \par
}
\par
\par
}
{\xe \v candidate_generation\:Trie}
{\xe \v Trie\:candidate_generation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::candidate_generation (const {\b itemtype} & {\i frequent_size})}
}\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Generates candidates. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i frequent_size} Size of the frequent itemsets that generate the candidates. \par
}
\par
\par
}
{\xe \v candidate_generation_assist\:Trie}
{\xe \v Trie\:candidate_generation_assist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::candidate_generation_assist (unsigned long {\i actual_state}, const {\b itemtype} {\i frequent_size}, const {\b itemtype} {\i actual_sizet}, set< {\b itemtype} > & {\i maybe_candidate}){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Generates candidate of size more than two. \par
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v candidate_generation_two\:Trie}
{\xe \v Trie\:candidate_generation_two}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::candidate_generation_two (){\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Generates candidate of size two. \par
\par
\par
}
{\xe \v delete_edge\:Trie}
{\xe \v Trie\:delete_edge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::delete_edge (const unsigned long {\i fromState}, const unsigned long {\i toState}){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the edge that goes to a given state. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i fromState} the state from the edge starts. \par
{\i toState} the state to the edge points. \par
}
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_infrequent\:Trie}
{\xe \v Trie\:delete_infrequent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::delete_infrequent (const unsigned long {\i min_occurrence})}
}\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes unfrequent itemsets. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The threshold of absolute support. \par
}
\par
\par
}
{\xe \v delete_infrequent_more\:Trie}
{\xe \v Trie\:delete_infrequent_more}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::delete_infrequent_more (const unsigned long {\i min_occurrence}){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the nodes that represent infrequent itemsets. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The occurence threshold \par
}
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_infrequent_one\:Trie}
{\xe \v Trie\:delete_infrequent_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::delete_infrequent_one (const unsigned long {\i min_occurrence}){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the nodes that represent infrequent itemsets of size 1. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The occurence threshold \par
}
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_infrequent_two\:Trie}
{\xe \v Trie\:delete_infrequent_two}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::delete_infrequent_two (const unsigned long {\i min_occurrence}){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the nodes that represent infrequent itemsets of size 2. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The occurence threshold\par
}
\par
temp_counter_array[stateIndex_1-1] will never be used again!\par
temp_counter_array will never be used again! \par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v find_candidate\:Trie}
{\xe \v Trie\:find_candidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::find_candidate (const vector< {\b itemtype} > & {\i basket}, const {\b itemtype} {\i candidate_size}, const unsigned long {\i counter} = 1)}
}\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Increases the counter of those candidates that are contained by the given basket. \par
\par
\par
}
{\xe \v find_candidate_more\:Trie}
{\xe \v Trie\:find_candidate_more}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::find_candidate_more (const vector< {\b itemtype} > & {\i basket}, const {\b itemtype} {\i candidate_size}, vector< {\b itemtype} >::const_iterator {\i it_basket}, const unsigned long {\i actual_state}, const {\b itemtype} {\i actual_size}, const unsigned long {\i counter} = 1){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Increases the counter for those itemsets that is contained by the given basket. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i basket} the given basket \par
{\i candidate_size} The size of the candidates \par
{\i it_basket} *it_basket lead to the actual_state. Only items following this item need to be considered \par
{\i actual_state} The index of the actual state \par
{\i actual_size} The number of items that are already found \par
{\i counter} The number the processed basket occures in the transactional database \par
}
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v find_candidate_one\:Trie}
{\xe \v Trie\:find_candidate_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::find_candidate_one (const vector< {\b itemtype} > & {\i basket}){\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Increases the counter for those items that are in the given basket. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i basket} the given basket \par
}
\par
\par
}
{\xe \v find_candidate_two\:Trie}
{\xe \v Trie\:find_candidate_two}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::find_candidate_two (const vector< {\b itemtype} > & {\i basket}, const unsigned long {\i counter} = 1){\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Increases the counter for those itempairs that are in the given basket. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i basket} the given basket \par
{\i counter} The number the processed basket occures in the transactional database \par
}
\par
\par
}
{\xe \v is_all_subset_frequent\:Trie}
{\xe \v Trie\:is_all_subset_frequent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Trie::is_all_subset_frequent (const set< {\b itemtype} > & {\i maybe_candidate}) const{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Decides if all subset of of an itemset is contained in the trie. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i maybe_candidate} The itemset that has to be checked. \par
}
\par
\par
}
{\xe \v is_included\:Trie}
{\xe \v Trie\:is_included}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Trie::is_included (const set< {\b itemtype} > & {\i an_itemset}) const{\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
It decides whether the given itemset is included in the trie or not. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i an_itemset} The given itemset. \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0, if the itemset is not included, otherwise the state number, that represents the itemset. \par
}\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v max_path_set\:Trie}
{\xe \v Trie\:max_path_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::max_path_set (const unsigned long {\i stateIndex}){\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the maximal path value. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i stateIndex} the state whose max_path value has to be set. \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true, if no update was required (original value was correct), otherwise false. \par
}\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v node_number\:Trie}
{\xe \v Trie\:node_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Trie::node_number () const}
}\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the number of nodes in the trie. \par
\par
\par
}
{\xe \v show_content\:Trie}
{\xe \v Trie\:show_content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::show_content () const{\f2  [virtual]}}
}\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Displays the trie. \par
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v statistics\:Trie}
{\xe \v Trie\:statistics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::statistics () const{\f2  [virtual]}}
}\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Displays the memory need of the trie. \par
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v write_content_to_file\:Trie}
{\xe \v Trie\:write_content_to_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::write_content_to_file (ofstream & {\i outcomefile}) const}
}\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Writes the content (frequent itemsets) to the file. \par
\par
\par
}
{\xe \v write_content_to_file_assist\:Trie}
{\xe \v Trie\:write_content_to_file_assist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie::write_content_to_file_assist (ofstream & {\i outcomefile}, const unsigned long {\i actual_state}, const {\b itemtype} {\i item_size}, const {\b itemtype} {\i actual_size}, set< {\b itemtype} > & {\i frequent_itemset}) const{\f2  [protected, virtual]}}
}\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Writes out the content of the trie (frequent itemset and counters). \par
\par
Reimplemented in {\b Trie_hash} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v countervector\:Trie}
{\xe \v Trie\:countervector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<unsigned long> {\b Trie::countervector}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
countervector stores the occurences of the itemsets \par
countervector[i] stores the occurence of the itemset represented by the i{\super th}  node. \par
\par
}
{\xe \v inv_orderarray\:Trie}
{\xe \v Trie\:inv_orderarray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b itemtype}> {\b Trie::inv_orderarray}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
inverse of orderarray: orderarray[inv_orderarray[i]]=i \par
\par
\par
}
{\xe \v itemarray\:Trie}
{\xe \v Trie\:itemarray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< vector<{\b itemtype}> > {\b Trie::itemarray}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
itemarray stores the label of the edges. \par
itemarray[i] belongs to the i{\super th}  node. itemarray[i][j] stores the label of the j{\super th}  edge (of the i{\super th}  node). A label is a positive integer number (the code of an item). \par
\par
}
{\xe \v maxpath\:Trie}
{\xe \v Trie\:maxpath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b itemtype}> {\b Trie::maxpath}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
maxpath stores the legth of the longest paths. \par
maxpath[i] stores the legth of the longest path starting from the i{\super th}  node. \par
\par
}
{\xe \v orderarray\:Trie}
{\xe \v Trie\:orderarray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b itemtype}> {\b Trie::orderarray}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The frequency order of the items. \par
orderarray[1] is the most frequent item, orderarray[2] is the second most frequent... \par
\par
}
{\xe \v parent\:Trie}
{\xe \v Trie\:parent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<unsigned long> {\b Trie::parent}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v statearray\:Trie}
{\xe \v Trie\:statearray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< vector<unsigned long> > {\b Trie::statearray}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
stetearray stores the end node of the edges. \par
statearray[i] belongs to the i{\super th}  node. statearray[i][j] stores the end node of the j{\super th}  edge (of the i{\super th}  node). \par
\par
}
{\xe \v temp_counter_array\:Trie}
{\xe \v Trie\:temp_counter_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< vector<unsigned long> > {\b Trie::temp_counter_array}{\f2  [protected]}}
}\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
temp_counter_array stores the occurences of the itempairs \par
countervector[i][j] stores the occurence of the itempair (orderarray[i],orderarray[j]). \par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Trie.hpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Trie.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Trie_hash Class Reference\par \pard\plain 
{\tc\tcl2 \v Trie_hash}
{\xe \v Trie_hash}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <Trie_hash.hpp>}\par
Inheritance diagram for Trie_hash:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classTrie__hash.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Trie_hash} (const  {\b itemtype} child_threshold_in=5)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b statistics} () const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Displays the memory need of the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b show_content} () const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Displays the trie. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b from_hash_to_normal} (const  unsigned long state_index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Alters a node from hash table to normal node. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b from_normal_to_hash} (const  unsigned long state_index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Alters a node from normal node to hash table. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delete_edge} (const  unsigned long from_state, const  unsigned long to_state)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the edge that goes to a given state. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b max_path_set} (const  unsigned long state_index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Sets the maximal path value. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_empty_state} (const  unsigned long from_state, const  {\b itemtype} item, const  unsigned long counter)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Adds an empty state to the trie. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b is_included} (const  set< {\b itemtype} > &an_itemset) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i It decides whether the given itemset is included in the trie or not. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delete_infrequent_one} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the nodes that represent infrequent itemsets of size 1. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delete_infrequent_two} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the nodes that represent infrequent itemsets of size 2. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b delete_infrequent_more} (const  unsigned long min_occurrence)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Deletes the nodes that represent infrequent itemsets. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b candidate_generation_assist} (unsigned long actual_state, const  {\b itemtype} frequent_size, const  {\b itemtype} actual_size, set< {\b itemtype} > &maybe_candidate)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Generates candidate of size more than two. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b find_candidate_more} (const  vector< {\b itemtype} > &basket, const  {\b itemtype} candidate_size, vector< {\b itemtype} >::const_iterator it_basket, const  unsigned long actual_state, const  {\b itemtype} actual_size, const  unsigned long counter=1)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Increases the counter for those itemsets that is contained by the given basket. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b assoc_rule_assist} (ofstream &outcomefile, const  double min_conf, unsigned long actual_state, set< {\b itemtype} > &consequence_part) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_content_to_file_assist} (ofstream &outcomefile, const  unsigned long actual_state, const  {\b itemtype} item_size, const  {\b itemtype} actual_size, set< {\b itemtype} > &frequent_itemset) const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Writes out the content of the trie (frequent itemset and counters). }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< bool > {\b type_vector}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i It stores the type of the nodes. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b itemtype} {\b child_threshold}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i When the child number of a node is higher than child_threshold it is altered to hash table. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b itemtype} {\b hash_modulus}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The modulus of the hash table. }\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Ferenc Bodon \par
}\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Trie_hash\:Trie_hash}
{\xe \v Trie_hash\:Trie_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Trie_hash::Trie_hash (const {\b itemtype} {\i child_threshold_in} = 5)}
}\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add_empty_state\:Trie_hash}
{\xe \v Trie_hash\:add_empty_state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::add_empty_state (const unsigned long {\i fromState}, const {\b itemtype} {\i item}, const unsigned long {\i counter}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Adds an empty state to the trie. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i fromState} The state number that point to the new state. \par
{\i item} The label of the new edge \par
{\i counter} The initial counter of the new state \par
}
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v assoc_rule_assist\:Trie_hash}
{\xe \v Trie_hash\:assoc_rule_assist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::assoc_rule_assist (ofstream & {\i outcomefile}, const double {\i min_conf}, unsigned long {\i actual_state}, set< {\b itemtype} > & {\i consequence_part}) const{\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v candidate_generation_assist\:Trie_hash}
{\xe \v Trie_hash\:candidate_generation_assist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::candidate_generation_assist (unsigned long {\i actual_state}, const {\b itemtype} {\i frequent_size}, const {\b itemtype} {\i actual_size}, set< {\b itemtype} > & {\i maybe_candidate}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Generates candidate of size more than two. \par
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABI \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_edge\:Trie_hash}
{\xe \v Trie_hash\:delete_edge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::delete_edge (const unsigned long {\i fromState}, const unsigned long {\i toState}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the edge that goes to a given state. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i fromState} the state from the edge starts. \par
{\i toState} the state to the edge points. \par
}
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_infrequent_more\:Trie_hash}
{\xe \v Trie_hash\:delete_infrequent_more}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::delete_infrequent_more (const unsigned long {\i min_occurrence}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the nodes that represent infrequent itemsets. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The occurence threshold \par
}
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_infrequent_one\:Trie_hash}
{\xe \v Trie_hash\:delete_infrequent_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::delete_infrequent_one (const unsigned long {\i min_occurrence}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the nodes that represent infrequent itemsets of size 1. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The occurence threshold \par
}
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v delete_infrequent_two\:Trie_hash}
{\xe \v Trie_hash\:delete_infrequent_two}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::delete_infrequent_two (const unsigned long {\i min_occurrence}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes the nodes that represent infrequent itemsets of size 2. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i min_occurrence} The occurence threshold\par
}
\par
temp_counter_array[stateIndex_1-1] will never be used again!\par
temp_counter_array will never be used again! \par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v find_candidate_more\:Trie_hash}
{\xe \v Trie_hash\:find_candidate_more}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::find_candidate_more (const vector< {\b itemtype} > & {\i basket}, const {\b itemtype} {\i candidate_size}, vector< {\b itemtype} >::const_iterator {\i it_basket}, const unsigned long {\i actual_state}, const {\b itemtype} {\i actual_size}, const unsigned long {\i counter} = 1){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Increases the counter for those itemsets that is contained by the given basket. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i basket} the given basket \par
{\i candidate_size} The size of the candidates \par
{\i it_basket} *it_basket lead to the actual_state. Only items following this item need to be considered \par
{\i actual_state} The index of the actual state \par
{\i actual_size} The number of items that are already found \par
{\i counter} The number the processed basket occures in the transactional database \par
}
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v from_hash_to_normal\:Trie_hash}
{\xe \v Trie_hash\:from_hash_to_normal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::from_hash_to_normal (const unsigned long {\i stateIndex}){\f2  [private]}}
}\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Alters a node from hash table to normal node. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i stateIndex} The node that has to be altered. \par
}
\par
\par
}
{\xe \v from_normal_to_hash\:Trie_hash}
{\xe \v Trie_hash\:from_normal_to_hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::from_normal_to_hash (const unsigned long {\i stateIndex}){\f2  [private]}}
}\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Alters a node from normal node to hash table. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i stateIndex} The node that has to be altered. \par
}
\par
\par
}
{\xe \v is_included\:Trie_hash}
{\xe \v Trie_hash\:is_included}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long Trie_hash::is_included (const set< {\b itemtype} > & {\i an_itemset}) const{\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
It decides whether the given itemset is included in the trie or not. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i an_itemset} The given itemset. \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0, if the itemset is not included, otherwise the state number, that represents the itemset. \par
}\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v max_path_set\:Trie_hash}
{\xe \v Trie_hash\:max_path_set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::max_path_set (const unsigned long {\i stateIndex}){\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the maximal path value. \par
{\par
{\b Parameters:}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i stateIndex} the state whose max_path value has to be set. \par
}
{{\b \par
Returns:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true, if no update was required (original value was correct), otherwise false. \par
}\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v show_content\:Trie_hash}
{\xe \v Trie_hash\:show_content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::show_content () const{\f2  [virtual]}}
}\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Displays the trie. \par
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v statistics\:Trie_hash}
{\xe \v Trie_hash\:statistics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::statistics () const{\f2  [virtual]}}
}\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Displays the memory need of the trie. \par
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\xe \v write_content_to_file_assist\:Trie_hash}
{\xe \v Trie_hash\:write_content_to_file_assist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Trie_hash::write_content_to_file_assist (ofstream & {\i outcomefile}, const unsigned long {\i actual_state}, const {\b itemtype} {\i item_size}, const {\b itemtype} {\i actual_size}, set< {\b itemtype} > & {\i frequent_itemset}) const{\f2  [private, virtual]}}
}\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Writes out the content of the trie (frequent itemset and counters). \par
\par
Reimplemented from {\b Trie} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v child_threshold\:Trie_hash}
{\xe \v Trie_hash\:child_threshold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b itemtype} {\b Trie_hash::child_threshold}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
When the child number of a node is higher than child_threshold it is altered to hash table. \par
\par
\par
}
{\xe \v hash_modulus\:Trie_hash}
{\xe \v Trie_hash\:hash_modulus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b itemtype} {\b Trie_hash::hash_modulus}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The modulus of the hash table. \par
Since hash tables have to be perfect the hash modulus equals the number of frequent items. \par
\par
}
{\xe \v type_vector\:Trie_hash}
{\xe \v Trie_hash\:type_vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<bool> {\b Trie_hash::type_vector}{\f2  [private]}}
}\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
It stores the type of the nodes. \par
If type_vector[i] is true, the i{\super th}  node is an original node, otherwise it is a hash table. \par
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Trie_hash.hpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Trie_hash.cpp}\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
APRIORI algorithm File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Apriori.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Apriori.cpp}
{\xe \v Apriori.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Apriori.hpp"}\par
{\f2 #include <iostream>}\par
{\f2 #include <vector>}\par
{\f2 #include <set>}\par
{\f2 #include <cmath>}\par
\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b std}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Apriori.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Apriori.hpp}
{\xe \v Apriori.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Trie.hpp"}\par
{\f2 #include "Trie_hash.hpp"}\par
{\f2 #include <map>}\par
\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Apriori}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i This class implements the APRIORI algirithm. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b itemsetLess}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i This struct is responsible for comparing two itemsets. }\par
\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v main.cpp}
{\xe \v main.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fstream>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <getopt.h>}\par
{\f2 #include "Apriori.hpp"}\par
\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b usage} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i This procedure displays the usage of the program. }\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}
}\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
}
{\xe \v usage\:main.cpp}
{\xe \v main.cpp\:usage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void usage ()}
}\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This procedure displays the usage of the program. \par
\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Trie.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Trie.cpp}
{\xe \v Trie.cpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Trie.hpp"}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <algorithm>}\par
\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Trie.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Trie.hpp}
{\xe \v Trie.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fstream>}\par
{\f2 #include <iostream>}\par
{\f2 #include <set>}\par
{\f2 #include <vector>}\par
{\f2 #include <cstdio>}\par
\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Trie}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Trie (or prefix-tree) is a tree-based datastructure. }\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long {\b itemtype}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v itemtype\:Trie.hpp}
{\xe \v Trie.hpp\:itemtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long {\b itemtype}}
}\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{\b \par
Author:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Ferenc Bodon \par
}\par
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Trie_hash.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Trie_hash.cpp}
{\xe \v Trie_hash.cpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include "Trie_hash.hpp"}\par
\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Trie_hash.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Trie_hash.hpp}
{\xe \v Trie_hash.hpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Trie.hpp"}\par
\par
}
\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Trie_hash}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}